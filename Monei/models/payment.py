# coding: utf-8

"""
    MONEI API v1

    <p>The MONEI API is organized around <a href=\"https://en.wikipedia.org/wiki/Representational_State_Transfer\">REST</a> principles. Our API is designed to be intuitive and developer-friendly.</p> <h3>Base URL</h3> <p>All API requests should be made to:</p> <pre><code>https://api.monei.com/v1 </code></pre> <h3>Environment</h3> <p>MONEI provides two environments:</p> <ul> <li><strong>Test Environment</strong>: For development and testing without processing real payments</li> <li><strong>Live Environment</strong>: For processing real transactions in production</li> </ul> <h3>Client Libraries</h3> <p>We provide official SDKs to simplify integration:</p> <ul> <li><a href=\"https://github.com/MONEI/monei-php-sdk\">PHP SDK</a></li> <li><a href=\"https://github.com/MONEI/monei-python-sdk\">Python SDK</a></li> <li><a href=\"https://github.com/MONEI/monei-node-sdk\">Node.js SDK</a></li> <li><a href=\"https://postman.monei.com/\">Postman Collection</a></li> </ul> <p>Our SDKs handle authentication, error handling, and request formatting automatically.</p> <p>You can download the OpenAPI specification from the <a href=\"https://js.monei.com/api/v1/openapi.json\">https://js.monei.com/api/v1/openapi.json</a> and generate your own client library using the <a href=\"https://openapi-generator.tech/\">OpenAPI Generator</a>.</p> <h3>Important Requirements</h3> <ul> <li>All API requests must be made over HTTPS</li> <li>If you are not using our official SDKs, you <strong>must provide a valid <code>User-Agent</code> header</strong> with each request</li> <li>Requests without proper authentication will return a <code>401 Unauthorized</code> error</li> </ul> <h3>Error Handling</h3> <p>The API returns consistent error codes and messages to help you troubleshoot issues. Each response includes a <code>statusCode</code> attribute indicating the outcome of your request.</p> <h3>Rate Limits</h3> <p>The API implements rate limiting to ensure stability. If you exceed the limits, requests will return a <code>429 Too Many Requests</code> status code.</p> 

    The version of the OpenAPI document: 1.5.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from Monei.models.payment_billing_details import PaymentBillingDetails
from Monei.models.payment_cancellation_reason import PaymentCancellationReason
from Monei.models.payment_customer import PaymentCustomer
from Monei.models.payment_last_refund_reason import PaymentLastRefundReason
from Monei.models.payment_next_action import PaymentNextAction
from Monei.models.payment_payment_method import PaymentPaymentMethod
from Monei.models.payment_sequence import PaymentSequence
from Monei.models.payment_session_details import PaymentSessionDetails
from Monei.models.payment_shipping_details import PaymentShippingDetails
from Monei.models.payment_shop import PaymentShop
from Monei.models.payment_status import PaymentStatus
from Monei.models.payment_trace_details import PaymentTraceDetails
from typing import Optional, Set
from typing_extensions import Self

class Payment(BaseModel):
    """
    Payment
    """ # noqa: E501
    id: Optional[StrictStr] = Field(default=None, description="Unique identifier for the payment.")
    amount: Optional[StrictInt] = Field(default=None, description="Amount intended to be collected by this payment. A positive integer representing how much to charge in the smallest currency unit (e.g., 100 cents to charge 1.00 USD). ")
    currency: Optional[StrictStr] = Field(default=None, description="Three-letter [ISO currency code](https://en.wikipedia.org/wiki/ISO_4217), in uppercase. Must be a supported currency. ")
    order_id: Optional[StrictStr] = Field(default=None, description="An order ID from your system. A unique identifier that can be used to reconcile the payment with your internal system. ", alias="orderId")
    description: Optional[StrictStr] = Field(default=None, description="An arbitrary string attached to the payment. Often useful for displaying to users. ")
    account_id: Optional[StrictStr] = Field(default=None, description="MONEI Account identifier.", alias="accountId")
    authorization_code: Optional[StrictStr] = Field(default=None, description="Unique identifier provided by the bank performing transaction. ", alias="authorizationCode")
    livemode: Optional[StrictBool] = Field(default=None, description="Has the value `true` if the resource exists in live mode or the value `false` if the resource exists in test mode.")
    status: Optional[PaymentStatus] = None
    status_code: Optional[StrictStr] = Field(default=None, description="Payment status code. ", alias="statusCode")
    status_message: Optional[StrictStr] = Field(default=None, description="Human readable status message, can be displayed to a user. ", alias="statusMessage")
    customer: Optional[PaymentCustomer] = None
    shop: Optional[PaymentShop] = None
    billing_details: Optional[PaymentBillingDetails] = Field(default=None, alias="billingDetails")
    shipping_details: Optional[PaymentShippingDetails] = Field(default=None, alias="shippingDetails")
    refunded_amount: Optional[StrictInt] = Field(default=None, description="Amount in cents refunded (can be less than the amount attribute on the payment if a partial refund was issued). ", alias="refundedAmount")
    last_refund_amount: Optional[StrictInt] = Field(default=None, description="Amount in cents refunded in the last transaction.", alias="lastRefundAmount")
    last_refund_reason: Optional[PaymentLastRefundReason] = Field(default=None, alias="lastRefundReason")
    cancellation_reason: Optional[PaymentCancellationReason] = Field(default=None, alias="cancellationReason")
    session_details: Optional[PaymentSessionDetails] = Field(default=None, alias="sessionDetails")
    trace_details: Optional[PaymentTraceDetails] = Field(default=None, alias="traceDetails")
    payment_token: Optional[StrictStr] = Field(default=None, description="A permanent token represents a payment method used in the payment. Pass `generatePaymentToken: true` when you creating a payment to generate it. You can pass it as `paymentToken` parameter to create other payments with the same payment method. This token does not expire, and should only be used server-side. ", alias="paymentToken")
    payment_method: Optional[PaymentPaymentMethod] = Field(default=None, alias="paymentMethod")
    sequence: Optional[PaymentSequence] = None
    sequence_id: Optional[StrictStr] = Field(default=None, description="A permanent identifier that refers to the initial payment of a sequence of payments. This value needs to be sent in the path for `RECURRING` payments. ", alias="sequenceId")
    store_id: Optional[StrictStr] = Field(default=None, description="A unique identifier of the Store. If specified the payment is attached to this Store. ", alias="storeId")
    point_of_sale_id: Optional[StrictStr] = Field(default=None, description="A unique identifier of the Point of Sale. If specified the payment is attached to this Point of Sale. If there is a QR code attached to the same Point of Sale, this payment will be available by scanning the QR code. ", alias="pointOfSaleId")
    metadata: Optional[Dict[str, Any]] = Field(default=None, description="A set of key-value pairs that you can attach to a resource. This can be useful for storing additional information about the resource in a structured format.")
    next_action: Optional[PaymentNextAction] = Field(default=None, alias="nextAction")
    created_at: Optional[StrictInt] = Field(default=None, description="Time at which the resource was created. Measured in seconds since the Unix epoch.", alias="createdAt")
    updated_at: Optional[StrictInt] = Field(default=None, description="Time at which the resource updated last time. Measured in seconds since the Unix epoch.", alias="updatedAt")
    __properties: ClassVar[List[str]] = ["id", "amount", "currency", "orderId", "description", "accountId", "authorizationCode", "livemode", "status", "statusCode", "statusMessage", "customer", "shop", "billingDetails", "shippingDetails", "refundedAmount", "lastRefundAmount", "lastRefundReason", "cancellationReason", "sessionDetails", "traceDetails", "paymentToken", "paymentMethod", "sequence", "sequenceId", "storeId", "pointOfSaleId", "metadata", "nextAction", "createdAt", "updatedAt"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Payment from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of customer
        if self.customer:
            _dict['customer'] = self.customer.to_dict()
        # override the default output from pydantic by calling `to_dict()` of shop
        if self.shop:
            _dict['shop'] = self.shop.to_dict()
        # override the default output from pydantic by calling `to_dict()` of billing_details
        if self.billing_details:
            _dict['billingDetails'] = self.billing_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of shipping_details
        if self.shipping_details:
            _dict['shippingDetails'] = self.shipping_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of session_details
        if self.session_details:
            _dict['sessionDetails'] = self.session_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of trace_details
        if self.trace_details:
            _dict['traceDetails'] = self.trace_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of payment_method
        if self.payment_method:
            _dict['paymentMethod'] = self.payment_method.to_dict()
        # override the default output from pydantic by calling `to_dict()` of sequence
        if self.sequence:
            _dict['sequence'] = self.sequence.to_dict()
        # override the default output from pydantic by calling `to_dict()` of next_action
        if self.next_action:
            _dict['nextAction'] = self.next_action.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Payment from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "amount": obj.get("amount"),
            "currency": obj.get("currency"),
            "orderId": obj.get("orderId"),
            "description": obj.get("description"),
            "accountId": obj.get("accountId"),
            "authorizationCode": obj.get("authorizationCode"),
            "livemode": obj.get("livemode"),
            "status": obj.get("status"),
            "statusCode": obj.get("statusCode"),
            "statusMessage": obj.get("statusMessage"),
            "customer": PaymentCustomer.from_dict(obj["customer"]) if obj.get("customer") is not None else None,
            "shop": PaymentShop.from_dict(obj["shop"]) if obj.get("shop") is not None else None,
            "billingDetails": PaymentBillingDetails.from_dict(obj["billingDetails"]) if obj.get("billingDetails") is not None else None,
            "shippingDetails": PaymentShippingDetails.from_dict(obj["shippingDetails"]) if obj.get("shippingDetails") is not None else None,
            "refundedAmount": obj.get("refundedAmount"),
            "lastRefundAmount": obj.get("lastRefundAmount"),
            "lastRefundReason": obj.get("lastRefundReason"),
            "cancellationReason": obj.get("cancellationReason"),
            "sessionDetails": PaymentSessionDetails.from_dict(obj["sessionDetails"]) if obj.get("sessionDetails") is not None else None,
            "traceDetails": PaymentTraceDetails.from_dict(obj["traceDetails"]) if obj.get("traceDetails") is not None else None,
            "paymentToken": obj.get("paymentToken"),
            "paymentMethod": PaymentPaymentMethod.from_dict(obj["paymentMethod"]) if obj.get("paymentMethod") is not None else None,
            "sequence": PaymentSequence.from_dict(obj["sequence"]) if obj.get("sequence") is not None else None,
            "sequenceId": obj.get("sequenceId"),
            "storeId": obj.get("storeId"),
            "pointOfSaleId": obj.get("pointOfSaleId"),
            "metadata": obj.get("metadata"),
            "nextAction": PaymentNextAction.from_dict(obj["nextAction"]) if obj.get("nextAction") is not None else None,
            "createdAt": obj.get("createdAt"),
            "updatedAt": obj.get("updatedAt")
        })
        return _obj


